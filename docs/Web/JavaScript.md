---
sidebarDepth: 1
---
# JavaScript 
[[toc]]
## 第一章 基本语法

### 基本语法

::: tip 区分大小写
&emsp;&emsp;JavaScript是一种**区分大小写**的语言，这就是说，在输入语言的关键字，变量，函数名以及所有的标识符时，都**必须采取一致的字符大小写形式**。 例如关键字“while"就必须被输入为"while"，而不能输入为"While"或者"WHILE",同样的，"online","Online","OnLine"和"ONLINE"是四个不同的变量名。
:::

::: info 标识符命名规则
1、标识符中可以含有字母，数字，下划线 _，$  ；<br>
2、标识符不能以数字开头。用字母，下划线 _，$开头都没问题；<br>
3、标识符不能是ES中的关键字或是保留字；<br>
4、标识符一般都采用驼峰命名法。首字母小写，每个单词的开头字母大写，其余字母小写；<br>
>PS：关键保留字参考:[关键保留字参考](https://www.runoob.com/js/js-reserved.html)<br>
:::

::: tabs#注释

@tab 单行

单行注释以 // 开头。

@tab 多行注释

多行注释以 /*    */。

:::

::: danger 严格模式
JavaScript 严格模式即在严格的条件下运行。使用 ``use strict`` 指令
:::

### 变量
声明变量：let、const、var。ES6之前创建变量用的是var,之后创建变量用的是let/const
::: warning 区别
1. var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。<br>
let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。<br>
const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，且不能修改。<br>
2. var可以先使用，后声明，因为存在变量提升；let必须先声明后使用。<br>
3. var是允许在相同作用域内重复声明同一个变量的，而let与const不允许这一现象。<br>
4. 在全局上下文中，基于let声明的全局变量和全局对象GO（window）没有任何关系 ;<br>
var声明的变量会和GO有映射关系；
5. 会产生暂时性死区；<br>
6. let /const/function会把当前所在的大括号(除函数之外)作为一个全新的块级上下文，应用这个机制，在开发项目的时候，遇到循环事件绑定等类似的需求，无需再自己构建闭包来存储，只要基于let的块作用特征即可解决<br>
:::

### 数据类型
**Number**、**String**、**Boolean**、**BigInt**、**Symbol**、**Null**、**Undefined**、**Object**   8种<br>
**基本类型(值类型)** <br>
 Number(数字),String(字符串),Boolean(布尔),Symbol(符号),null(空),undefined(未定义)在内存中占据固定大小，保存在栈内存中<br>
**引用类型(复杂数据类型)** <br>
Object(对象)、Function(函数)。其他还有Array(数组)、Date(日期)、RegExp(正则表达式)、特殊的基本包装类型(String、Number、Boolean) 以及单体内置对象(Global、Math)等 引用类型的值是对象 保存在堆内存中，栈内存存储的是对象的变量标识符以及对象在堆内存中的存储地址。<br>
**使用场景：**<br>
``Symbol``：使用Symbol来作为对象属性名(key)  利用该特性，把一些不需要对外操作和访问的属性使用Symbol来定义。<br>
``BigInt``：由于在 Number 与 BigInt 之间进行转换会损失精度，因而建议仅在值可能大于253 时使用 BigInt 类型，并且不在两种类型之间进行相互转换。<br>
### 操作符
#### 一元操作符
+、-、*、/、++、--
### 位操作符
○ 位非：~ <br>
○ 位与：&<br>
○ 位或：|<br>
○ 异或：^<br>
○ 左移：<<<br>
○ 有符号右移：>><br>
○ 无符号右移：>>><br>
### 布尔操作符
○ 逻辑非：！ <br>
○ 逻辑与：&& <br>
○ 逻辑或：|| <br>
### 乘性操作符
*、/、%
### 加性操作符
+、-
### 关系操作符
○ 小于：< <br>
○ 大于：> <br>
○ 小于等于：<= <br>
○ 大于等于：>== <br>
### 相等操作符
○ 相等：== <br>
○ 全等：=== <br>
○ 不等：！=<br>
### 条件操作符
条件=条件语句？true（语句一）：false（语句二）
### 赋值操作符
○ = <br>
○ *=; /=; %= <br>
○ +=; -=;   <br>
○ <<=; >>=; >>>=<br>

### 基本语句
::: info if语句
if 语句
```js
if (condition)
{
    当条件为 true 时执行的代码
}
```
if...else语句
```js
if (condition)
{
    当条件为 true 时执行的代码
}
else
{
    当条件不为 true 时执行的代码
}
```
if...else if...else 语句
```js
if (condition1)
{
    当条件 1 为 true 时执行的代码
}
else if (condition2)
{
    当条件 2 为 true 时执行的代码
}
else
{
  当条件 1 和 条件 2 都不为 true 时执行的代码
}
```
:::

::: danger While语句
```js
while (条件)
{
    需要执行的代码
}
```
:::

::: warning do-while语句

```js
do
{
    需要执行的代码
}
while (条件);
```

:::

::: tip for语句
```js
for (语句 1; 语句 2; 语句 3)
{
    被执行的代码块
}
```
:::

::: note for-in语句
```js
var person={fname:"Bill",lname:"Gates",age:56}; 
 
for (x in person)  // x 为属性名
{
    txt=txt + person[x];
}
```
:::

::: danger break/continue语句
break 语句用于跳出循环。continue 用于跳过循环中的一个迭代。
```js
for (i=0;i<10;i++)
{
    if (i==3)
    {
        break;
    }
    x=x + "The number is " + i + "<br>";
}
```

```js
for (i=0;i<=10;i++)
{
    if (i==3) continue;
    x=x + "The number is " + i + "<br>";
}
```
:::

::: warning swich语句
```js
switch(n)
{
    case 1:
        执行代码块 1
        break;
    case 2:
        执行代码块 2
        break;
    default:
        与 case 1 和 case 2 不同时执行的代码
}
```
:::

::: tip lable语句

:::

::: info with语句

:::
## 第二章 作用域（链）

::: danger 作用域
通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。<br>
JavaScript (ES6前) 中的作用域有两种：<br>
● 全局作用域:作用于所有代码执行的环境(整个script 标签内部)或者一个独立的 js 文件<br>
● 局部作用域(函数作用域):作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域<br>

:::

::: info 作用域链
1. 只要是代码，就至少有一个作用域<br>
2. 写在函数内部的叫局部作用域<br>
3. 如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域<br>
4. 根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链<br>
● 作用域链：采取就近原则的方式来查找变量最终的值。<br>
```js
// 作用域链: 内部函数访问外部函数的变量，采取的是链式查找的方式来决定取哪个值，这种结构我们称为作用域链表

var num = 10;
funtion fn() { //外部函数
    var num = 20;
    
    function fun() { //内部函数
        console.log(num);  // 20 ,一级一级访问
    }
}
```
:::

## 第三章 对象与内置对象

### 对象

### Math对象

### Date()日期对象

### 数组Arry对象

### 字符串对象


## 第四章 面向对象

## 第五章 函数进阶

## 第六章 BOM

## 第七章 DOM

## 第八章 事件

## 第九章 JSON

## 第十章 AJAX 与 axios

## 第十章 错误处理与调试

## 第十一章 异步编程

## 第十二章 防抖与节流

## 第十三章 正则表达式